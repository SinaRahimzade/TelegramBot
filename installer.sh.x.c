#if 0
	shc Version 4.0.3, Generic Shell Script Compiler
	GNU GPL Version 3 Md Jahidul Hamid <jahidulhamid@yahoo.com>

	shc -v -f installer.sh 
#endif

static  char data [] = 
#define      xecc_z	15
#define      xecc	((&data[1]))
	"\216\267\212\074\141\314\133\266\135\374\260\144\234\111\220\170"
	"\245\247"
#define      lsto_z	1
#define      lsto	((&data[18]))
	"\222"
#define      msg2_z	19
#define      msg2	((&data[23]))
	"\135\023\304\314\016\135\340\031\226\241\117\030\240\254\102\137"
	"\201\235\011\256\364\022\277\136\225\114"
#define      tst1_z	22
#define      tst1	((&data[46]))
	"\245\215\314\246\303\133\270\343\260\264\242\342\023\163\356\327"
	"\301\134\215\351\345\111\256\207\071"
#define      date_z	1
#define      date	((&data[70]))
	"\067"
#define      chk1_z	22
#define      chk1	((&data[72]))
	"\270\031\320\220\200\101\162\144\342\036\242\300\260\115\022\174"
	"\342\067\177\060\036\313\306\177"
#define      rlax_z	1
#define      rlax	((&data[95]))
	"\241"
#define      inlo_z	3
#define      inlo	((&data[96]))
	"\002\242\301"
#define      opts_z	1
#define      opts	((&data[99]))
	"\307"
#define      shll_z	10
#define      shll	((&data[102]))
	"\335\027\252\107\046\337\265\151\205\024\331\227"
#define      text_z	1847
#define      text	((&data[403]))
	"\150\011\003\352\316\043\124\154\120\075\156\241\166\047\303\170"
	"\375\023\250\271\060\047\272\271\144\171\134\022\206\162\056\146"
	"\115\307\221\045\061\225\124\200\010\044\011\232\305\341\200\276"
	"\143\126\352\314\264\101\363\051\264\377\170\275\333\044\161\100"
	"\074\020\372\306\301\200\140\247\012\032\063\165\142\223\027\304"
	"\300\150\223\322\047\247\335\146\024\253\210\022\131\060\375\205"
	"\100\057\233\250\233\326\350\354\276\041\263\166\211\257\200\113"
	"\201\271\177\054\236\152\077\350\372\207\256\214\132\023\200\252"
	"\132\114\304\133\131\005\107\033\234\042\321\313\372\000\176\061"
	"\247\317\214\376\076\337\350\043\077\137\254\350\142\255\023\247"
	"\066\004\107\241\115\223\244\010\261\243\212\153\062\175\334\312"
	"\140\021\214\327\005\110\227\007\346\127\155\137\212\036\214\304"
	"\112\230\244\320\340\146\251\344\231\111\211\067\261\271\056\354"
	"\113\275\113\252\142\213\030\360\313\162\261\207\317\054\301\332"
	"\075\056\163\010\247\232\357\016\375\126\002\205\162\316\115\223"
	"\241\175\025\031\077\107\143\365\375\040\053\351\335\325\153\351"
	"\205\247\212\277\327\045\007\030\307\144\227\060\011\020\155\170"
	"\210\335\271\244\007\012\146\113\031\120\020\041\253\212\377\001"
	"\261\110\257\205\374\115\251\024\106\077\101\106\222\373\324\076"
	"\301\302\345\215\110\215\166\156\212\117\365\033\276\131\353\000"
	"\256\257\141\140\143\204\225\005\257\276\370\034\166\301\351\045"
	"\015\317\160\356\077\153\244\002\026\041\315\335\125\111\163\012"
	"\053\103\261\303\113\326\304\011\052\341\357\006\234\126\044\067"
	"\236\116\135\333\025\316\373\340\303\133\246\073\256\162\121\325"
	"\370\211\261\133\020\004\022\032\171\104\025\153\232\157\047\311"
	"\157\070\136\364\334\107\206\325\076\165\177\065\061\266\346\252"
	"\163\077\303\152\014\366\046\330\051\305\140\124\237\260\064\363"
	"\024\062\122\261\205\052\163\174\135\036\137\057\177\036\356\210"
	"\320\242\074\222\031\213\124\111\313\245\013\124\206\035\000\375"
	"\224\126\173\324\047\266\152\334\217\356\123\300\252\315\055\132"
	"\061\031\121\352\333\225\150\115\364\203\060\211\071\232\255\261"
	"\020\041\240\264\056\350\077\365\344\342\057\172\177\346\354\272"
	"\047\325\134\116\204\362\350\232\227\344\142\320\346\117\155\171"
	"\152\177\141\136\046\266\314\056\004\117\236\030\351\064\104\141"
	"\341\053\162\326\024\260\064\112\054\162\167\036\155\234\152\162"
	"\344\041\314\330\210\123\076\356\053\161\254\103\106\125\313\114"
	"\203\223\021\050\255\112\047\017\046\135\122\210\361\140\356\067"
	"\350\154\332\350\326\134\364\200\317\036\121\324\260\115\376\327"
	"\152\150\025\307\057\346\214\360\344\315\246\062\353\266\151\144"
	"\262\347\243\024\266\331\042\055\130\164\151\064\024\045\057\011"
	"\016\110\006\153\053\274\031\264\147\215\052\301\240\373\210\167"
	"\307\331\030\363\251\150\214\103\144\361\255\161\352\251\317\054"
	"\156\060\072\362\141\171\134\230\066\125\245\324\277\223\113\274"
	"\006\125\121\200\050\253\041\220\160\356\365\322\172\125\156\150"
	"\204\111\066\202\345\303\010\012\316\103\150\222\364\055\023\342"
	"\061\142\042\165\264\004\323\273\063\260\110\070\126\342\033\322"
	"\373\121\022\217\226\365\027\154\224\117\054\151\140\341\117\075"
	"\142\117\074\107\116\361\040\225\140\112\302\162\376\302\064\253"
	"\136\300\133\177\215\210\377\027\307\346\250\274\046\377\254\040"
	"\160\350\213\265\307\371\042\264\022\105\354\227\272\033\122\317"
	"\331\261\206\052\057\176\152\116\352\170\277\046\020\371\047\363"
	"\344\362\102\021\372\001\253\212\323\000\004\222\264\056\377\353"
	"\053\054\017\107\246\075\155\253\244\264\157\333\031\356\176\020"
	"\041\326\205\151\231\201\060\377\155\100\224\060\174\340\350\235"
	"\223\141\224\012\115\070\274\341\053\027\053\112\303\317\007\103"
	"\207\005\024\153\201\242\134\054\367\011\204\155\066\074\143\070"
	"\263\022\325\162\243\230\133\221\076\132\342\032\137\306\372\326"
	"\264\376\207\241\345\144\354\350\004\154\334\133\103\225\121\243"
	"\131\260\341\243\065\237\027\055\124\154\223\175\147\213\222\377"
	"\213\012\163\222\163\240\332\311\157\145\151\214\343\266\004\060"
	"\162\341\003\332\075\017\361\111\065\165\137\076\030\050\240\161"
	"\351\066\073\373\232\045\273\332\104\073\114\346\146\355\277\020"
	"\240\154\105\162\377\045\255\005\355\165\121\034\215\307\147\114"
	"\117\252\116\220\107\254\245\265\025\213\320\332\043\027\177\352"
	"\143\347\012\143\142\275\315\204\107\201\356\221\261\026\156\164"
	"\341\117\365\367\102\357\052\230\051\304\021\376\023\030\312\105"
	"\044\202\312\154\106\273\215\204\115\243\021\142\111\113\320\340"
	"\000\133\014\253\117\306\010\222\006\141\025\262\007\102\361\135"
	"\152\017\274\153\242\010\226\233\316\052\107\273\073\073\053\324"
	"\134\347\352\071\005\354\040\325\034\322\075\236\352\377\330\261"
	"\126\124\134\272\021\006\315\254\115\324\001\227\273\042\063\055"
	"\215\313\330\176\364\022\315\310\223\060\143\251\272\233\100\211"
	"\364\054\203\211\054\277\123\061\170\057\202\107\157\132\106\004"
	"\023\202\342\374\152\174\003\275\000\171\302\164\105\174\044\313"
	"\041\273\177\121\337\052\110\313\220\370\236\035\104\060\125\206"
	"\023\207\374\360\204\121\033\033\075\127\317\123\067\246\146\135"
	"\061\127\057\153\205\064\220\114\242\220\075\322\222\106\007\236"
	"\062\154\017\257\070\021\307\102\235\312\076\241\105\073\006\062"
	"\247\200\354\173\303\205\100\115\211\345\101\000\166\156\325\224"
	"\230\263\065\232\313\021\212\037\077\031\012\362\250\222\174\251"
	"\012\105\145\266\055\103\276\070\024\152\055\046\042\251\160\243"
	"\362\104\070\251\146\246\142\070\163\243\226\074\316\321\304\212"
	"\113\364\150\035\017\241\174\211\044\176\055\102\255\163\042\072"
	"\314\333\160\270\327\360\010\353\345\043\201\320\222\062\315\365"
	"\255\136\221\257\245\160\351\046\344\213\353\016\335\023\140\322"
	"\305\201\031\037\003\004\313\070\377\220\244\105\041\015\071\241"
	"\174\301\131\154\370\162\337\340\002\216\030\242\215\226\342\060"
	"\031\212\244\163\070\001\214\034\172\365\214\217\320\170\206\023"
	"\204\065\256\222\032\323\244\137\345\235\325\052\251\347\213\134"
	"\050\372\057\134\324\353\325\015\011\236\045\264\111\213\027\274"
	"\061\141\124\051\352\337\103\027\271\362\136\032\074\052\317\304"
	"\362\134\150\162\216\355\271\123\164\170\300\207\250\151\020\342"
	"\310\033\305\325\055\103\202\212\125\065\337\312\134\026\064\202"
	"\043\224\050\073\126\067\242\226\255\264\354\005\320\165\304\243"
	"\153\251\247\257\166\162\135\021\131\013\370\105\207\372\324\115"
	"\036\363\264\242\367\032\117\016\347\314\372\324\135\035\163\153"
	"\160\037\344\001\114\015\321\010\035\015\176\154\075\173\005\211"
	"\313\315\271\237\023\302\225\006\035\332\125\153\016\352\270\176"
	"\041\331\327\224\202\311\110\276\005\326\245\350\174\347\202\172"
	"\162\024\277\007\015\306\260\271\022\137\202\031\355\320\317\354"
	"\112\054\245\040\147\172\101\115\146\070\222\022\044\176\120\234"
	"\256\055\014\177\247\313\331\172\243\375\044\165\217\050\114\301"
	"\111\106\020\236\344\265\173\137\076\032\230\274\271\170\152\171"
	"\043\067\342\027\364\103\340\213\252\057\360\356\150\120\376\064"
	"\360\125\327\252\024\311\150\307\311\047\140\363\141\343\011\305"
	"\175\041\131\167\311\176\364\131\007\271\221\171\060\354\320\147"
	"\341\231\310\141\231\327\307\360\343\040\047\013\056\015\060\100"
	"\303\053\202\324\151\275\005\240\203\263\323\223\072\131\210\126"
	"\011\323\047\204\111\247\015\175\173\352\146\072\273\226\162\303"
	"\134\306\153\300\045\207\001\254\167\231\267\050\063\320\144\014"
	"\273\002\165\213\313\173\353\174\010\352\322\242\357\022\135\177"
	"\340\176\132\305\113\203\235\034\120\272\345\325\054\330\237\307"
	"\212\117\345\341\025\112\207\164\045\140\115\111\375\342\055\256"
	"\041\370\172\104\217\014\254\156\336\267\303\262\016\306\302\256"
	"\000\033\273\237\200\331\260\343\342\330\030\237\304\154\342\265"
	"\200\205\200\227\160\161\007\063\125\067\241\116\036\311\160\317"
	"\041\274\327\323\332\006\152\316\021\043\251\066\157\160\117\357"
	"\345\316\176\340\260\050\317\350\245\213\271\261\217\102\345\116"
	"\022\257\263\131\355\070\022\335\316\116\263\244\243\304\014\237"
	"\323\257\301\313\311\211\163\102\223\350\055\112\074\350\353\020"
	"\275\246\076\135\113\041\070\116\057\122\240\030\252\234\352\051"
	"\243\100\053\167\117\257\377\370\207\242\125\223\131\312\157\353"
	"\034\376\304\073\021\362\355\032\077\152\120\321\272\170\174\341"
	"\175\231\057\313\112\031\356\316\365\124\036\326\174\003\161\102"
	"\245\131\140\004\217\347\331\171\155\302\001\044\113\372\231\237"
	"\137\104\374\142\364\150\304\346\272\267\224\315\361\163\360\176"
	"\107\377\260\125\007\201\162\300\232\014\274\115\311\233\340\220"
	"\127\202\216\232\352\372\101\055\376\355\126\201\047\016\114\130"
	"\271\106\213\311\333\040\144\253\130\074\271\331\361\213\152\263"
	"\321\015\275\102\143\034\361\007\056\121\164\342\375\312\014\204"
	"\231\367\263\102\331\173\124\214\305\121\255\077\021\123\120\111"
	"\332\320\204\006\234\165\215\375\362\254\201\035\204\245\074\243"
	"\264\063\230\172\371\163\256\124\041\170\154\063\321\017\360\273"
	"\006\251\023\227\036\027\161\212\212\224\066\362\310\244\245\376"
	"\052\264\272\225\225\316\013\162\274\037\232\047\327\017\333\016"
	"\064\254\213\216\377\176\023\140\257\310\350\321\327\041\050\273"
	"\166\252\043\130\000\241\233\320\050\250\074\004\234\050\344\261"
	"\254\323\311\150\061\332\362\371\055\134\367\221\147\370\150\172"
	"\141\305\303\065\153\111\177\113\365\311\127\127\162\055\215\067"
	"\137\301\305\124\021\345\163\353\015\016\032\106\027\150\337\226"
	"\347\123\321\251\062\114\275\054\367\216\173\027\100\045\054\212"
	"\234\360\233\324\102\215\163\313\005\160\153\313\323\227\033\136"
	"\004\175\120\035\324\142\271\111\117\155\347\342\135\275\204\211"
	"\247\300\074\174\201\233\025\004\326\254\047\331\072\300\205\356"
	"\304\171\121\120\077\162\164\215\140\243\115\154\113\224\354\313"
	"\253\373\345\121\106\071\350\300\360\371\100\025\377\137\334\025"
	"\230\061\137\275\325\100\303\056\215\106\005\073\317\031\250\106"
	"\201\126\075\055\114\354\004\311\062\071\141\362\374\061\157\242"
	"\117\163\200\344\273\234\261\323\363\073\041\123\075\042\105\202"
	"\020\025\237\104\277\050\203\050\037\141\006\102\047\312\046\346"
	"\210\215\137\123\225\336\167\171\155\367\051\122\037\344\005\114"
	"\237\173\342\367\321\367\036\030\365\212\116\140\322\162\023\140"
	"\107\051\034\177\101\355\233\237\070\172\220\363\212\053\020\016"
	"\052\207\236\362\323\046\074\253\344\015\243\221\366\234\362\041"
	"\105\333\032\336\011\300\107\303\224\203\002\301\327\327\034\002"
	"\321\226\214\367\147\136\170\036\023\270\156\203\024\332\173\355"
	"\172\306\110"
#define      tst2_z	19
#define      tst2	((&data[2611]))
	"\135\332\123\106\142\307\110\173\354\143\004\023\121\105\300\246"
	"\245\165\151\337\061"
#define      chk2_z	19
#define      chk2	((&data[2634]))
	"\333\152\273\203\025\066\015\074\363\030\165\153\270\175\325\355"
	"\334\275\016\254\331\100"
#define      pswd_z	256
#define      pswd	((&data[2710]))
	"\161\122\355\122\221\161\256\256\311\257\251\035\121\171\034\242"
	"\215\263\345\205\164\215\143\254\063\337\166\020\353\277\310\310"
	"\254\153\026\175\154\201\136\313\145\262\253\272\262\341\175\006"
	"\040\351\037\370\055\226\176\256\250\014\000\157\106\162\213\013"
	"\372\341\077\130\215\127\076\025\144\027\113\104\065\260\210\367"
	"\077\113\201\323\146\121\123\215\354\172\142\013\061\252\145\115"
	"\246\175\167\122\201\174\101\046\267\131\234\377\151\277\322\276"
	"\321\247\373\065\230\100\206\221\325\270\276\335\266\071\262\223"
	"\233\047\200\155\311\207\210\161\137\034\227\330\265\003\122\054"
	"\053\016\243\223\370\371\110\151\125\242\362\202\317\001\241\006"
	"\144\132\050\313\260\267\035\050\275\121\307\024\105\103\350\130"
	"\133\257\314\332\276\252\034\134\145\357\231\175\234\261\123\033"
	"\061\141\333\334\066\272\056\300\320\020\065\076\307\206\030\126"
	"\235\074\071\025\170\234\031\007\262\205\344\212\277\044\264\321"
	"\044\362\377\041\040\146\032\120\206\001\146\372\121\054\262\111"
	"\152\012\216\375\157\022\367\151\252\301\064\066\351\143\127\055"
	"\274\151\016\244\276\050\307\255\100\361\177\331\313\240\060\320"
	"\255\156\000\115\342\205\145\152\252\100\320\303\254\233\151\343"
	"\105\312\214\270\200\005\207\342\164\143\150\335\131\251\341\350"
	"\104\253\076\025\146\230\373\123\333\143\055\344\153\026\166\024"
	"\031\377\126\023\252\133\257\306\074\012\160\145\232\103\331\015"
#define      msg1_z	65
#define      msg1	((&data[2994]))
	"\306\302\014\167\200\336\375\265\325\375\306\103\311\363\053\257"
	"\115\065\150\176\217\170\252\217\132\052\267\264\055\220\062\362"
	"\033\157\221\301\353\241\117\231\001\343\245\260\266\076\203\074"
	"\027\243\220\151\157\200\336\060\004\346\276\323\067\026\277\063"
	"\205\354\170\060\260\362\015\277\267\171\165\244\362\225"/* End of data[] */;
#define      hide_z	4096
#define SETUID 0	/* Define as 1 to call setuid(0) at start of script */
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define HARDENING	0	/* Define as 1 to disable ptrace/dump the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

#if HARDENING
static const char * shc_x[] = {
"/*",
" * Copyright 2019 - Intika <intika@librefox.org>",
" * Replace ******** with secret read from fd 21",
" * Also change arguments location of sub commands (sh script commands)",
" * gcc -Wall -fpic -shared -o shc_secret.so shc_secret.c -ldl",
" */",
"",
"#define _GNU_SOURCE /* needed to get RTLD_NEXT defined in dlfcn.h */",
"#define PLACEHOLDER \"********\"",
"#include <dlfcn.h>",
"#include <stdlib.h>",
"#include <string.h>",
"#include <unistd.h>",
"#include <stdio.h>",
"#include <signal.h>",
"",
"static char secret[128000]; //max size",
"typedef int (*pfi)(int, char **, char **);",
"static pfi real_main;",
"",
"// copy argv to new location",
"char **copyargs(int argc, char** argv){",
"    char **newargv = malloc((argc+1)*sizeof(*argv));",
"    char *from,*to;",
"    int i,len;",
"",
"    for(i = 0; i<argc; i++){",
"        from = argv[i];",
"        len = strlen(from)+1;",
"        to = malloc(len);",
"        memcpy(to,from,len);",
"        // zap old argv space",
"        memset(from,'\\0',len);",
"        newargv[i] = to;",
"        argv[i] = 0;",
"    }",
"    newargv[argc] = 0;",
"    return newargv;",
"}",
"",
"static int mymain(int argc, char** argv, char** env) {",
"    //fprintf(stderr, \"Inject main argc = %d\\n\", argc);",
"    return real_main(argc, copyargs(argc,argv), env);",
"}",
"",
"int __libc_start_main(int (*main) (int, char**, char**),",
"                      int argc,",
"                      char **argv,",
"                      void (*init) (void),",
"                      void (*fini)(void),",
"                      void (*rtld_fini)(void),",
"                      void (*stack_end)){",
"    static int (*real___libc_start_main)() = NULL;",
"    int n;",
"",
"    if (!real___libc_start_main) {",
"        real___libc_start_main = dlsym(RTLD_NEXT, \"__libc_start_main\");",
"        if (!real___libc_start_main) abort();",
"    }",
"",
"    n = read(21, secret, sizeof(secret));",
"    if (n > 0) {",
"      int i;",
"",
"    if (secret[n - 1] == '\\n') secret[--n] = '\\0';",
"    for (i = 1; i < argc; i++)",
"        if (strcmp(argv[i], PLACEHOLDER) == 0)",
"          argv[i] = secret;",
"    }",
"",
"    real_main = main;",
"",
"    return real___libc_start_main(mymain, argc, argv, init, fini, rtld_fini, stack_end);",
"}",
"",
0};
#endif /* HARDENING */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

#if HARDENING

#include <sys/ptrace.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/prctl.h>
#define PR_SET_PTRACER 0x59616d61

/* Seccomp Sandboxing Init */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include <sys/types.h>
#include <sys/prctl.h>
#include <sys/syscall.h>
#include <sys/socket.h>

#include <linux/filter.h>
#include <linux/seccomp.h>
#include <linux/audit.h>

#define ArchField offsetof(struct seccomp_data, arch)

#define Allow(syscall) \
    BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, SYS_##syscall, 0, 1), \
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_ALLOW)

struct sock_filter filter[] = {
    /* validate arch */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, ArchField),
    BPF_JUMP( BPF_JMP+BPF_JEQ+BPF_K, AUDIT_ARCH_X86_64, 1, 0),
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),

    /* load syscall */
    BPF_STMT(BPF_LD+BPF_W+BPF_ABS, offsetof(struct seccomp_data, nr)),

    /* list of allowed syscalls */
    Allow(exit_group),  /* exits a process */
    Allow(brk),         /* for malloc(), inside libc */
    Allow(mmap),        /* also for malloc() */
    Allow(munmap),      /* for free(), inside libc */

    /* and if we don't match above, die */
    BPF_STMT(BPF_RET+BPF_K, SECCOMP_RET_KILL),
};
struct sock_fprog filterprog = {
    .len = sizeof(filter)/sizeof(filter[0]),
    .filter = filter
};

/* Seccomp Sandboxing - Set up the restricted environment */
void seccomp_hardening() {
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
        perror("Could not start seccomp:");
        exit(1);
    }
    if (prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &filterprog) == -1) {
        perror("Could not start seccomp:");
        exit(1);
    }
} 
/* End Seccomp Sandboxing Init */

void shc_x_file() {
    FILE *fp;
    int line = 0;

    if ((fp = fopen("/tmp/shc_x.c", "w")) == NULL ) {exit(1); exit(1);}
    for (line = 0; shc_x[line]; line++)	fprintf(fp, "%s\n", shc_x[line]);
    fflush(fp);fclose(fp);
}

int make() {
	char * cc, * cflags, * ldflags;
    char cmd[4096];

	cc = getenv("CC");
	if (!cc) cc = "cc";

	sprintf(cmd, "%s %s -o %s %s", cc, "-Wall -fpic -shared", "/tmp/shc_x.so", "/tmp/shc_x.c -ldl");
	if (system(cmd)) {remove("/tmp/shc_x.c"); return -1;}
	remove("/tmp/shc_x.c"); return 0;
}

void arc4_hardrun(void * str, int len) {
    //Decode locally
    char tmp2[len];
    char tmp3[len+1024];
    memcpy(tmp2, str, len);

	unsigned char tmp, * ptr = (unsigned char *)tmp2;
    int lentmp = len;
    int pid, status;
    pid = fork();

    shc_x_file();
    if (make()) {exit(1);}

    setenv("LD_PRELOAD","/tmp/shc_x.so",1);

    if(pid==0) {

        //Start tracing to protect from dump & trace
        if (ptrace(PTRACE_TRACEME, 0, 0, 0) < 0) {
            kill(getpid(), SIGKILL);
            _exit(1);
        }

        //Decode Bash
        while (len > 0) {
            indx++;
            tmp = stte[indx];
            jndx += tmp;
            stte[indx] = stte[jndx];
            stte[jndx] = tmp;
            tmp += stte[indx];
            *ptr ^= stte[tmp];
            ptr++;
            len--;
        }

        //Do the magic
        sprintf(tmp3, "%s %s", "'********' 21<<<", tmp2);

        //Exec bash script //fork execl with 'sh -c'
        system(tmp2);

        //Empty script variable
        memcpy(tmp2, str, lentmp);

        //Clean temp
        remove("/tmp/shc_x.so");

        //Sinal to detach ptrace
        ptrace(PTRACE_DETACH, 0, 0, 0);
        exit(0);
    }
    else {wait(&status);}

    /* Seccomp Sandboxing - Start */
    seccomp_hardening();

    exit(0);
}
#endif /* HARDENING */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

void chkenv_end(void);

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask = (unsigned long)getpid();
	stte_0();
	 key(&chkenv, (void*)&chkenv_end - (void*)&chkenv);
	 key(&data, sizeof(data));
	 key(&mask, sizeof(mask));
	arc4(&mask, sizeof(mask));
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

void chkenv_end(void){}

#if HARDENING

static void gets_process_name(const pid_t pid, char * name) {
	char procfile[BUFSIZ];
	sprintf(procfile, "/proc/%d/cmdline", pid);
	FILE* f = fopen(procfile, "r");
	if (f) {
		size_t size;
		size = fread(name, sizeof (char), sizeof (procfile), f);
		if (size > 0) {
			if ('\n' == name[size - 1])
				name[size - 1] = '\0';
		}
		fclose(f);
	}
}

void hardening() {
    prctl(PR_SET_DUMPABLE, 0);
    prctl(PR_SET_PTRACER, -1);

    int pid = getppid();
    char name[256] = {0};
    gets_process_name(pid, name);

    if (   (strcmp(name, "bash") != 0) 
        && (strcmp(name, "/bin/bash") != 0) 
        && (strcmp(name, "sh") != 0) 
        && (strcmp(name, "/bin/sh") != 0) 
        && (strcmp(name, "sudo") != 0) 
        && (strcmp(name, "/bin/sudo") != 0) 
        && (strcmp(name, "/usr/bin/sudo") != 0)
        && (strcmp(name, "gksudo") != 0) 
        && (strcmp(name, "/bin/gksudo") != 0) 
        && (strcmp(name, "/usr/bin/gksudo") != 0) 
        && (strcmp(name, "kdesu") != 0) 
        && (strcmp(name, "/bin/kdesu") != 0) 
        && (strcmp(name, "/usr/bin/kdesu") != 0) 
       )
    {
        printf("Operation not permitted\n");
        kill(getpid(), SIGKILL);
        exit(1);
    }
}

#endif /* HARDENING */

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PT_ATTACHEXC) /* New replacement for PT_ATTACH */
   #if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
       #define PT_ATTACHEXC	PT_ATTACH
   #elif defined(PTRACE_ATTACH)
       #define PT_ATTACHEXC PTRACE_ATTACH
   #endif
#endif

void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PT_ATTACHEXC, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = argv[0];
	if (me == NULL) { me = getenv("_"); }
	if (me == 0) { fprintf(stderr, "E: neither argv[0] nor $_ works."); exit(1); }

	ret = chkenv(argc);
	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
#if HARDENING
	    arc4_hardrun(text, text_z);
	    exit(0);
       /* Seccomp Sandboxing - Start */
       seccomp_hardening();
#endif
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if SETUID
   setuid(0);
#endif
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if HARDENING
	hardening();
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
